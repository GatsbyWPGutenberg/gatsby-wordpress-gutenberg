const { default: pluck } = require(`graphql-tag-pluck`)
const { parse, Kind } = require(`graphql`)
const path = require(`path`)
const fs = require(`fs-extra`)
const chokidar = require(`chokidar`)
const bodyParser = require(`body-parser`)
/**
 * The main theme philosophy - user only cares about block component implementation / all other things are auto-handled with choices to opt-out

 *  - the <Blocks /> component is autogenerated from querying sourced data - this way you only import/query blocks which are used in post's content

 *  - the <Blocks /> component file contains fragment definition on all the blocks/innerBlocks used in that post

 *  - user / child theme can provide block component implemention, if not the default 'unknown-block.js' is used (uses dangerouslySetInnerHTML internally)

 *  - user / child theme can create block component implementation inside its
 *      src/gatsby-theme-wordpress-gutenberg/components/blocks/[block-name] folder
 *      eq: src/gatsby-theme-wordpress-gutenberg/components/blocks/core/paragraph.[js,tsx or any other configured extension in gatsby]

 *  - the created component file should contain fragment definition on the block graphql type which will be
 *      automatically imported into the generated GutenbergBlocks[post-id] fragment and used
 *      in the pageQuery in the generated page component file sources

 *  - user/child theme can create template component implementation (file used when creating gatsby's page component)

 *  - to override (shadow) the shipped template user can create files in its src/gatsby-source-wordpress-gutenberg/templates with following rules:
 *   (Insipired by: https://wphierarchy.com/)
 *    - index.js - override shipped main template for all posts
 *    - by-id/[wordpress id].js - override template for post with id
 *    - by-link/[wordpress link pathname].js - override template for post with link eq: blog/hello-world.js
 *    - by-type/[gatsby's graphql typename]/[wordpress slug].js -- override template for typename with slug
 *    - by-type/[gatsby's graphql typename]/index.js - override template for same typename

 *  - the created template component can contain fragment definition on root Query type which will be
 *    automatically imported into the generated page query (useful to query post's YOAST seo/acf fields or all other gatsby's content)
 *    the user can use graphql $id variable in the graphql string which is the wordpress id of the post (Int!)

 *  - template components gets the <Blocks /> component as its children prop

 *  - TBD:
 *  - the page generation can be turned off completely, user can than import src/gatsby-theme-wordpress-gutenberg/blocks/by-id/[wordpress id].js
 *    or src/gatsby-theme-wordpress-gutenberg/blocks/by-link/[wordpress link pathname].js file and
 *    use the fragment GutenbergBlocks[postId] or GutenbergBlocks[linkPathname] in the page query manually
 */

/**
 * CONSTANTS
 */

const PLUGIN_NAME = require(`./package.json`).name
const BLOCKS_PATH = path.join(`.cache`, `fragments`, PLUGIN_NAME, `components`, `blocks`)
const PAGES_PATH = path.join(`.cache`, `fragments`, PLUGIN_NAME, PLUGIN_NAME, `pages`)

/**
 * MODULE VARIABLES
 */

// stores instance of chokidar watcher (for detecting changes through `develop` mode)
let watcher

const fragments = {
  GutenbergPostBlock: `
  fragment GutenbergPostBlock on GutenbergBlock {
    name
    id
  }
`,
}

const typenameToFieldName = ({ typename }) => typename.charAt(0).toLowerCase() + typename.slice(1)

/**
 * UTILITY FUNCTIONS
 */

const fetchPostIds = async ({ graphql }) => {
  const { data, errors } = await graphql(`
    query {
      allGutenbergContent {
        edges {
          node {
            postId
          }
        }
      }
    }
  `)

  if (errors) {
    throw errors[0]
  }

  return Array.from(new Set(data.allGutenbergContent.edges.map(({ node }) => node.postId)))
}

// fetches latest content node, when preview, also preview content nodes are queried
const fetchLatest = async ({ graphql, postId, preview }) => {
  // TODO: this should work, however the filters were returning wrong results
  // maybe post an issue to gatsby?

  //   const filters = [`postId: {eq: ${postId}}`]

  //   if (!preview) {
  //     filters.push(`isPreview: {eq: false}`, `link: {ne: null}`)
  //   }

  //   const query = `
  // ${fragments.GutenbergPostBlock}
  // query {
  //   allGutenbergContent(sort: {fields: [modifiedTime], order: [DESC]}, filter: {${filters.join(`, `)}}) {
  //     edges {
  //       node {
  //         id
  //         postId
  //         link
  //         modifiedTime
  //         isPreview
  //         blocks {
  //           __typename
  //           ...GutenbergPostBlock
  //           innerBlocks {
  //             __typename
  //             ...GutenbergPostBlock
  //           }
  //         }
  //       }
  //     }
  //   }
  // }
  // `

  // return (data.allGutenbergContent.edges.length && data.allGutenbergContent.edges[0].node) || null

  const { data, errors } = await graphql(`
    ${fragments.GutenbergPostBlock}
    query {
      allGutenbergContent(sort: { fields: [postId, modifiedTime], order: [ASC, DESC] }) {
        edges {
          node {
            id
            postId
            link
            slug
            parent {
              typename: __typename
            }
            modifiedTime
            isPreview
            blocks {
              __typename
              ...GutenbergPostBlock
              innerBlocks {
                __typename
                ...GutenbergPostBlock
              }
            }
          }
        }
      }
    }
  `)

  if (errors) {
    throw errors[0]
  }

  // we will do the filtering ourselves
  // nodes are sorted by modified time, so the first is the latest
  for (const edge of data.allGutenbergContent.edges) {
    const { node } = edge

    if (node.postId === postId) {
      if (preview) {
        return node
      } else if (node.link && !node.isPreview) {
        return node
      }
    }
  }

  return null
}

// fetches inner blocks of block
const fetchInnerBlocks = async ({ graphql, block: { __typename, id } }) => {
  const field = typenameToFieldName({ typename: __typename })

  const { data, errors } = await graphql(`
    ${fragments.GutenbergPostBlock}
    query {
      ${field}(id: {eq: "${id}"}) {
        innerBlocks {
          __typename
          ...GutenbergPostBlock
        }
      }
    }
  `)

  if (errors) {
    throw errors[0]
  }

  return data[field]
}

// creates fragment sdl for all blocks/innerBlocks
const createFragment = ({ name, blockFragmentNames, innerBlocksLevel, preview }) => {
  const spreads = blockFragmentNames.map(blockFragmentName => `...${blockFragmentName}`).join(` `)

  // since we cannot create recursive fragment definition,
  // we have to statically analyse nesting count and generate proper fields selections
  const generate = (level = 0) => {
    let fragment =
      level === 0
        ? `{ __typename id ${preview ? `clientId` : ``} ${spreads} `
        : ` innerBlocks { __typename ... on GutenbergBlock { id ${preview ? `clientId` : ``} } ${spreads}`

    if (level < innerBlocksLevel) {
      fragment += generate(level + 1)
    }

    fragment += ` }`

    return fragment
  }

  return `fragment ${name} on GutenbergBlock ${generate()}`
}

// creates source code for <Blocks/> component
const createBlocksComponentSource = ({ fragmentName, innerBlocksLevel, components, preview }) => `/* eslint-disable */
/* Warning: this file is autogerated, any changes would be lost */

import React from 'react'
import { graphql } from 'gatsby'

${components.map(({ componentPath, typename }) => `import ${typename} from '${componentPath}'`).join(`\n`)}

export const query = graphql\`${createFragment({
  name: fragmentName,
  blockFragmentNames: components.map(({ fragment }) => fragment.name.value),
  innerBlocksLevel,
  preview,
})}\`

const Blocks = ({blocks}) => {
  return (
    <>
      {blocks.map((block, i) => {  
        const children = block.innerBlocks ? <Blocks blocks={block.innerBlocks} /> : null;

        ${components
          .map(
            ({ typename }) => `if (block.__typename === '${typename}') {
            return <${typename} {...block} children={children} key={block.id} />
          }`
          )
          .join(`\n        `)}
         
        return null;
      })}
    </>
  );
};

export default Blocks
`

// creates source code for page
const createPageComponentSource = ({
  id,
  queryName,
  blocksComponentFragmentName,
  blocksComponentPath,
  templateComponentPath,
  templateComponentFragmentName,
}) => `/* eslint-disable */
/* Warning: this file is autogerated, any changes would be lost */
import React from 'react'
import { graphql } from 'gatsby'
import Blocks from '${blocksComponentPath}'
import PageTemplate from '${templateComponentPath}'

export const pageQuery = graphql\`
  query ${queryName}($postId: Int!) {
    gutenbergContent(id: {eq: "${id}"}, postId: {eq: $postId}) {
      blocks {
        ...${blocksComponentFragmentName}
      }
    }
    ${templateComponentFragmentName ? `...${templateComponentFragmentName}` : ``}
  }\`

const Page = props =>
  <PageTemplate {...props}>
    <Blocks blocks={props.data.gutenbergContent.blocks} />
  </PageTemplate>

export default Page
`

// creates source code for preview page
const createPreviewPageComponentSource = ({
  id,
  queryName,
  blocksComponentFragmentName,
  blocksComponentPath,
  templateComponentPath,
  templateComponentFragmentName,
}) => `/* eslint-disable */
/* Warning: this file is autogerated, any changes would be lost */
import React from 'react'
import { graphql } from 'gatsby'
import Blocks from '${blocksComponentPath}'
import PageTemplate from '${templateComponentPath}'
import PreviewPage from 'gatsby-theme-wordpress-gutenberg/src/components/previews/page'

export const pageQuery = graphql\`
  query ${queryName}($postId: Int!) {
    gutenbergContent(id: {eq: "${id}"}, postId: {eq: $postId}) {
      modifiedTime
      blocks {
        ...${blocksComponentFragmentName}
      }
    }
    ${templateComponentFragmentName ? `...${templateComponentFragmentName}` : ``}
  }\`

const Page = props =>
  <PreviewPage PageTemplate={PageTemplate} Blocks={Blocks} {...props} />

export default Page
`

// converts link to filename (last '/' is turned to index)
const linkToFilename = ({ link }) => {
  const pathname = new URL(link).pathname
  if (pathname === `/`) {
    return `index`
  }

  return pathname.replace(/\/$/, ``)
}

// extracts graphql sdl from graphql`` tag inside component file
const extractGraphql = async ({ componentPath }) => {
  try {
    const sdl = await pluck.fromFile(componentPath, {
      modules: [
        {
          name: `gatsby`,
          identifier: `graphql`,
        },
      ],
    })

    return parse(sdl)
  } catch (err) {
    return null
  }
}

// writes file to disk only on change/new file (avoids unnecessary rebuilds)
const writeFile = async ({ filePath, data }) => {
  const oldData = await fs.readFile(filePath, `utf-8`).catch(() => null)

  if (oldData !== data) {
    await fs.outputFile(filePath, data)
  }
}

// resolves component path which will be used in our generated sources
// uses same alghoritm as component shadowing so the component which
// is closest to the user's project in the template hierarchy wins
const resolveComponentPath = async ({ store, componentPath }) => {
  const extensions = store.getState().program.extensions
  const projectRoot = store.getState().program.directory

  // flattenedPlugins are already properly sorted accoridng to gatsby's template hierarchy
  // so the themes which use another themes are properly ordered
  const pluginPaths = store.getState().flattenedPlugins.map(flattenedPlugin => {
    if (flattenedPlugin.name === PLUGIN_NAME) {
      return path.join(flattenedPlugin.pluginFilepath, `src`)
    }

    return path.join(flattenedPlugin.pluginFilepath, `src`, `gatsby-theme-wordpress-gutenberg`)
  })

  // reverse reverses array in place, so we create a copy first
  const dirs = Array.from(new Set([projectRoot, ...[...pluginPaths].reverse()]))

  for (const dir of dirs) {
    const possiblePath = path.join(dir, componentPath)

    let exists = await fs.exists(possiblePath)

    if (exists) {
      return path
    }

    for (const extension of extensions) {
      const possiblePathWithExtension = `${possiblePath}${extension}`

      exists = await fs.exists(possiblePathWithExtension)
      if (exists) {
        return possiblePathWithExtension
      }
    }
  }

  return null
}

// resolves template component path which will be used in our generated sources as the page component
// uses same alghoritm as component shadowing so the component which
// is closest to the user's project in the template hierarchy wins
const resolveTemplateComponentPath = async ({ store, postId, link, typename, slug }) =>
  (await resolveComponentPath({ store, componentPath: path.join(`templates`, `by-id`, `${postId}`) })) ||
  (link &&
    (await resolveComponentPath({
      store,
      componentPath: path.join(`templates`, `by-link`, linkToFilename({ link })),
    }))) ||
  (typename &&
    slug &&
    (await resolveComponentPath({
      store,
      componentPath: path.join(`templates`, `by-type`, typename, slug),
    }))) ||
  (typename &&
    (await resolveComponentPath({
      store,
      componentPath: path.join(`templates`, `by-type`, typename, `index`),
    }))) ||
  (await resolveComponentPath({
    store,
    componentPath: path.join(`templates`, `index`),
  }))

// resolves unknown component path
// uses same alghoritm as component shadowing so the component which
// is closest to the user's project in the template hierarchy wins
const resolveUnknownComponentPath = options =>
  resolveComponentPath({
    ...options,
    componentPath: path.join(`components`, `unknown-block`),
  })

// resolves block component path
// uses same alghoritm as component shadowing so the component which
// is closest to the user's project in the template hierarchy wins
const resolveBlockComponentPath = async ({ blockName, ...options }) => {
  const possibleComponentPath = await resolveComponentPath({
    ...options,
    componentPath: path.join(`components`, `blocks`, blockName),
  })

  return possibleComponentPath
}

const extractBlockFragment = async ({ componentPath }) => {
  const document = await extractGraphql({ componentPath })

  if (document) {
    let fragment

    document.definitions.forEach(d => {
      if (d.kind === Kind.FRAGMENT_DEFINITION) {
        if (fragment) {
          throw new Error(`GraphQL Error: Component ${componentPath} must contain only one fragment definition`)
        }

        fragment = d
      }
    })

    return fragment
  }

  throw new Error(`Fragment definition in ${componentPath} not found`)
}

// visits all blocks
// applies visitor pattern on every block
// calculates and returns innerBlocks level
const visitBlocks = async ({ graphql, blocks, visitor }) => {
  let innerBlocksLevel = 0

  const visitInnerBlock = async ({ innerBlock, currentInnerBlocksLevel }) => {
    innerBlocksLevel = Math.max(currentInnerBlocksLevel, innerBlocksLevel)
    await visitor({ block: innerBlock })
    const result = await fetchInnerBlocks({ graphql, block: innerBlock })

    if (result) {
      const { innerBlocks } = result

      await Promise.all(
        innerBlocks.map(async innerBlock => {
          await visitInnerBlock({ innerBlock, currentInnerBlocksLevel: currentInnerBlocksLevel + 1 })
        })
      )
    }
  }

  await Promise.all(
    blocks.map(async block => {
      await visitor({ block })

      await Promise.all(
        block.innerBlocks.map(async innerBlock => {
          await visitInnerBlock({ innerBlock, currentInnerBlocksLevel: 1 })
        })
      )
    })
  )

  return innerBlocksLevel
}

const createMatchBlockComponent = () => {
  const cache = new Map()
  let unknownBlockData = null

  const match = async ({ block, ...options }) => {
    const { name, __typename: typename } = block

    const cachedData = cache.get(name)

    if (cachedData) {
      return cachedData
    }

    let componentPath = await resolveBlockComponentPath({ blockName: name, ...options })
    let fragment

    if (!componentPath) {
      if (!unknownBlockData) {
        const unknownComponentPath = await resolveUnknownComponentPath(options)

        unknownBlockData = {
          componentPath: unknownComponentPath,
          fragment: await extractBlockFragment({ componentPath: unknownComponentPath }),
        }
      }

      componentPath = unknownBlockData.componentPath
      fragment = unknownBlockData.fragment
    } else {
      fragment = await extractBlockFragment({ componentPath })
    }

    const data = {
      componentPath,
      fragment,
      typename,
    }

    cache.set(name, data)
    return data
  }

  match.cache = cache
  return match
}

const createPostPage = async (options, pluginOptions) => {
  const {
    actions,
    node,
    matchBlockComponent,
    blocksComponentPath,
    blocksComponentFragmentName,
    pageComponentPath,
    pagePath,
    queryName,
    preview,
    graphql,
  } = options

  const { createPage } = actions

  const {
    postId,
    link,
    id,
    slug,
    blocks,
    parent: { typename },
  } = node

  const componentByName = new Map()

  const innerBlocksLevel = await visitBlocks({
    blocks,
    ...options,
    visitor: async ({ block }) => {
      componentByName.set(block.name, await matchBlockComponent({ ...options, block }))
    },
  })

  await writeFile({
    filePath: blocksComponentPath,
    data: createBlocksComponentSource({
      fragmentName: blocksComponentFragmentName,
      innerBlocksLevel,
      components: Array.from(componentByName.values()),
      preview,
    }),
  })

  const templateComponentPath = await resolveTemplateComponentPath({
    ...options,
    postId,
    link,
    typename,
    slug,
  })

  const document = await extractGraphql({ componentPath: templateComponentPath })

  let templateComponentFragment = null

  if (document) {
    document.definitions.forEach(d => {
      if (d.kind === Kind.FRAGMENT_DEFINITION) {
        if (templateComponentFragment || d.typeCondition.name.value !== `Query`) {
          throw new Error(
            `GraphQL Error: Template \`${templateComponentFragment}\` must contain only one fragment definition on Query type.`
          )
        }

        templateComponentFragment = d
      }
    })
  }

  const data = preview
    ? createPreviewPageComponentSource({
        id,
        postId,
        queryName,
        blocksComponentFragmentName,
        blocksComponentPath,
        templateComponentPath,
        templateComponentFragmentName: templateComponentFragment && templateComponentFragment.name.value,
      })
    : createPageComponentSource({
        id,
        postId,
        queryName,
        blocksComponentFragmentName,
        blocksComponentPath,
        templateComponentPath,
        templateComponentFragmentName: templateComponentFragment && templateComponentFragment.name.value,
      })

  await writeFile({
    filePath: pageComponentPath,
    data,
  })

  const context = {
    postId,
  }

  if (preview) {
    const query = await graphql(`query {
      gutenbergPreviewsEvent(postId: {eq: ${postId}}) {
        changedTime
      }
    }`)

    if (query.errors) {
      throw query.errors[0]
    }

    context.changedTime =
      query.data && query.data.gutenbergPreviewsEvent && query.data.gutenbergPreviewsEvent.changedTime
  }

  await createPage({
    component: pageComponentPath,
    path: pagePath,
    context,
  })
}

const createPages = async (options, pluginOptions) => {
  const { graphql, store } = options

  const {
    program: { directory },
  } = store.getState()

  const matchBlockComponent = createMatchBlockComponent()

  // first we fetch all gutenberg post ids which we have sourced
  const postIds = await fetchPostIds({ graphql })

  await Promise.all(
    postIds.map(async postId => {
      const node = await fetchLatest({ graphql, postId })

      if (node) {
        await createPostPage(
          {
            ...options,
            node,
            matchBlockComponent,
            blocksComponentPath: path.join(directory, BLOCKS_PATH, `${postId}.js`),
            blocksComponentFragmentName: `GutenbergBlocks${postId}`,
            pagePath: new URL(node.link).pathname,
            pageComponentPath: path.join(directory, PAGES_PATH, `${linkToFilename({ link: node.link })}.js`),
            queryName: `GetGutenbergPost${postId}`,
          },
          pluginOptions
        )
      }

      const previewNode = await fetchLatest({ graphql, postId, preview: true })

      if (previewNode) {
        await createPostPage(
          {
            ...options,
            node: previewNode,
            preview: true,
            matchBlockComponent,
            blocksComponentPath: path.join(directory, BLOCKS_PATH, `previews`, `${postId}.js`),
            blocksComponentFragmentName: `GutenbergBlocks${postId}Preview`,
            pagePath: `___gutenberg/previews/${postId}`,
            pageComponentPath: path.join(directory, PAGES_PATH, `___gutenberg/previews/${postId}.js`),
            queryName: `GetGutenbergPost${postId}Preview`,
          },
          pluginOptions
        )
      }
    })
  )

  // FIXME: this is a hack to always refetch page queries in components, without this they are sometimes stale
  const now = new Date()
  await fs.utimes(__filename, now, now)
}

exports.onPreBootstrap = async options => {
  const { store } = options

  const {
    program: { directory },
  } = store.getState()

  // perform cleanup
  await Promise.all([fs.emptyDir(path.join(directory, BLOCKS_PATH)), fs.emptyDir(path.join(directory, PAGES_PATH))])
}

exports.createSchemaCustomization = async (options, pluginOptions) => {
  const { actions, schema } = options

  const { createTypes } = actions

  createTypes(
    schema.buildObjectType({
      name: `GutenbergPreviewsEvent`,
      fields: {
        changedTime: `String!`,
        postId: `Int!`,
      },
      interfaces: [`Node`],
    })
  )
}

exports.createPages = createPages

exports.createPagesStatefully = (options, pluginOptions) => {
  if (process.env.NODE_ENV === `development`) {
    if (watcher) {
      return
    }

    // to enhance developer experience we will track changes in all
    // child themes/root project's src/gatsby-theme-wordpress-gutenberg/{components/templates} and the theme itself
    // and regenerate source files upon change
    const { store, reporter } = options

    const program = store.getState().program
    const exts = program.extensions.map(e => `${e.slice(1)}`).join(`,`)

    const cb = () => {
      // if we are already running return
      if (cb.current) {
        return
      }
      reporter.info(`refreshing gutenberg pages`)
      cb.current = createPages(options, pluginOptions)
        .catch(err => {
          reporter.error(err)
        })
        .finally(() => {
          cb.current = null
        })
    }

    watcher = chokidar
      .watch(
        store.getState().flattenedPlugins.map(flattenedPlugin => {
          const directoryPath = flattenedPlugin.pluginFilepath
          return `${directoryPath}/${
            flattenedPlugin.name === PLUGIN_NAME ? `src/` : `src/gatsby-theme-wordpress-gutenberg/`
          }{components,templates}/**/*.{${exts}}`
        })
      )
      .on(`all`, cb)
  }
}

exports.onCreateDevServer = (options, pluginOptions) => {
  const { app, actions, reporter, getNodesByType, createNodeId, createContentDigest } = options

  const { previewToken } = pluginOptions

  const { createNode } = actions

  app.post(`/___gutenberg/previews/:postId(\\d+)`, async (req, res) => {
    const token = req.get(`X-Gatsby-Wordpress-Gutenberg-Preview-Token`)

    if (token && token !== previewToken) {
      res.status(401)
      res.send()
      return
    }

    const parse = bodyParser.json()
    parse(req, res, async () => {
      try {
        const postId = parseInt(req.params.postId)

        if (req.body.changedTime) {
          const node = {
            id: createNodeId(`gutenberg-previews-event-${postId}`),
            internal: {
              type: `GutenbergPreviewsEvent`,
            },
            postId,
            changedTime: req.body.changedTime,
          }

          node.internal.contentDigest = createContentDigest(JSON.stringify(node))
          await createNode(node)
        }

        let previewUrl = null

        for (const sitePageNode of getNodesByType(`SitePage`)) {
          const pathToMatch = `/___gutenberg/previews/${postId}`

          if (sitePageNode.path === pathToMatch) {
            previewUrl = pathToMatch
            break
          }
        }

        res.send({
          previewUrl,
        })
      } catch (error) {
        reporter.error(error)
        res.status(503)
        res.send()
      }
    })
  })
}
