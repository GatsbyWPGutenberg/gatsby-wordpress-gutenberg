const { default: pluck } = require(`graphql-tag-pluck`)
const { parse, Kind } = require(`graphql`)
const path = require(`path`)
const fs = require(`fs-extra`)
const chokidar = require(`chokidar`)
const { registerComponent, createResolverField } = require(`gatsby-plugin-graphql-component`)

/**
 *  - the <Blocks /> component is autogenerated from querying sourced data - this way you only import/query blocks which are used in post's content
 *  - the <Blocks /> component file contains fragment definition on all the blocks/innerBlocks used in that post

 *  - user / child theme can provide block component implemention, if not the default 'unknown-block.js' is used (uses dangerouslySetInnerHTML internally)

 *  - user / child theme can create block component implementation inside its
 *      src/gatsby-theme-wordpress-gutenberg/components/blocks/[block-name] folder
 *      eq: src/gatsby-theme-wordpress-gutenberg/components/blocks/core/paragraph.[js,jsx,ts,tsx]

 *  - the created component file should contain fragment definition on the block graphql type which will be
 *      automatically imported into the generated <Blocks /> component fragment

/**
 * CONSTANTS
 */

const PLUGIN_NAME = require(`./package.json`).name
// we are using .cache/fragments folder for auto-generated stuff
// because it is auto-watched by gatsby when it is parsing queries
const BLOCKS_PATH = path.join(`.cache`, `fragments`, PLUGIN_NAME, `blocks`)
const PAGES_PATH = path.join(`.cache`, `fragments`, PLUGIN_NAME, `pages`)

const typenameToFieldName = ({ typename }) => typename.charAt(0).toLowerCase() + typename.slice(1)

// creates fragment sdl for all blocks/innerBlocks
const createFragment = ({ name, blockFragmentNames, innerBlocksLevel, asPreview }) => {
  const spreads = blockFragmentNames.map(blockFragmentName => `...${blockFragmentName}`)

  if (asPreview) {
    spreads.push(`previewUUID`)
  }

  // since we cannot create recursive fragment definition,
  // we have to statically analyse nesting count and generate proper fields selections
  const generate = (level = 0) => {
    let fragment = level === 0 ? `{ __typename ${spreads.join(` `)} ` : ` innerBlocks { __typename ${spreads.join(` `)}`

    if (level < innerBlocksLevel) {
      fragment += generate(level + 1)
    }

    fragment += ` }`

    return fragment
  }

  return `fragment ${name} on WpBlock ${generate()}`
}

// extracts graphql sdl from graphql`` tag inside component file
const extractGraphql = async ({ componentPath }) => {
  try {
    const sdl = await pluck.fromFile(componentPath, {
      modules: [
        {
          name: `gatsby`,
          identifier: `graphql`,
        },
      ],
    })

    return parse(sdl)
  } catch (err) {
    return null
  }
}

// writes file to disk only on change/new file (avoids unnecessary rebuilds)
const writeFile = async ({ filePath, data }) => {
  const oldData = await fs.readFile(filePath, `utf-8`).catch(() => null)

  if (oldData !== data) {
    await fs.outputFile(filePath, data)
  }
}

// resolves component path which will be used in our generated sources
// uses same alghoritm as component shadowing so the component which
// is closest to the user's project in the template hierarchy wins
const resolveComponentPath = async ({ store, componentPath }) => {
  const extensions = [`.tsx`, `.ts`, `.mjs`, `.js`]
  const projectRoot = store.getState().program.directory

  // flattenedPlugins are already properly sorted accoridng to gatsby's template hierarchy
  // so the themes which use another themes are properly ordered
  const pluginPaths = store.getState().flattenedPlugins.map(flattenedPlugin => {
    if (flattenedPlugin.name === PLUGIN_NAME) {
      return path.join(flattenedPlugin.pluginFilepath, `src`)
    }

    return path.join(flattenedPlugin.pluginFilepath, `src`, `gatsby-theme-wordpress-gutenberg`)
  })

  // reverse reverses array in place, so we create a copy first
  const dirs = Array.from(new Set([projectRoot, ...[...pluginPaths].reverse()]))

  for (const dir of dirs) {
    const possiblePath = path.join(dir, componentPath)

    let exists = await fs.exists(possiblePath)

    if (exists) {
      return path
    }

    for (const extension of extensions) {
      const possiblePathWithExtension = `${possiblePath}${extension}`

      exists = await fs.exists(possiblePathWithExtension)
      if (exists) {
        return possiblePathWithExtension
      }
    }
  }

  return null
}

// resolves unknown component path
// uses same alghoritm as component shadowing so the component which
// is closest to the user's project in the template hierarchy wins
const resolveUnknownComponentPath = options =>
  resolveComponentPath({
    ...options,
    componentPath: path.join(`components`, `unknown-block`),
  })

// resolves block component path
// uses same alghoritm as component shadowing so the component which
// is closest to the user's project in the template hierarchy wins
const resolveBlockComponentPath = async ({ blockName, ...options }) => {
  const possibleComponentPath = await resolveComponentPath({
    ...options,
    componentPath: path.join(`components`, `blocks`, blockName),
  })

  return possibleComponentPath
}

const extractBlockFragment = async ({ store, componentPath }) => {
  const document = await extractGraphql({ componentPath })

  if (document) {
    let fragment

    document.definitions.forEach(d => {
      if (d.kind === Kind.FRAGMENT_DEFINITION) {
        if (fragment) {
          const { directory } = store.getState().program

          throw new Error(
            `GraphQL Error: Block component file at '${path.relative(
              directory,
              componentPath
            )}' must contain only one fragment definition`
          )
        }

        fragment = d
      }
    })

    return fragment
  }

  return null
}

// visits all blocks
// applies visitor pattern on every block
// calculates and returns innerBlocks level
const visitBlocks = async ({ blocks, visitor }) => {
  let innerBlocksLevel = 0

  const visitInnerBlock = async ({ innerBlock, currentInnerBlocksLevel }) => {
    innerBlocksLevel = Math.max(currentInnerBlocksLevel, innerBlocksLevel)
    const visitedBlock = await visitor({ block: innerBlock })

    if (visitedBlock.innerBlocks) {
      await Promise.all(
        visitedBlock.innerBlocks.map(async innerBlock => {
          await visitInnerBlock({ innerBlock, currentInnerBlocksLevel: currentInnerBlocksLevel + 1 })
        })
      )
    }
  }

  await Promise.all(
    blocks.map(async block => {
      const visitedBlock = await visitor({ block })

      await Promise.all(
        visitedBlock.innerBlocks.map(async innerBlock => {
          await visitInnerBlock({ innerBlock, currentInnerBlocksLevel: 1 })
        })
      )
    })
  )

  return innerBlocksLevel
}

const createBlockMatcher = () => {
  const cache = new Map()
  let unknownBlockData = null

  const match = async ({ block, ...options }) => {
    const { name, __typename } = block

    const cachedData = cache.get(name)

    if (cachedData) {
      return cachedData
    }

    let componentPath = await resolveBlockComponentPath({ ...options, blockName: name })
    let fragment

    if (!componentPath) {
      if (!unknownBlockData) {
        const unknownComponentPath = await resolveUnknownComponentPath(options)

        unknownBlockData = {
          componentPath: unknownComponentPath,
          fragment: await extractBlockFragment({ ...options, componentPath: unknownComponentPath }),
        }
      }

      componentPath = unknownBlockData.componentPath
      fragment = unknownBlockData.fragment
    } else {
      fragment = await extractBlockFragment({ ...options, componentPath })
    }

    const data = {
      componentPath,
      fragment,
      typename: `Wp${__typename}`,
    }

    cache.set(name, data)
    return data
  }

  match.cache = cache
  return match
}

const getBlockAtrributes = ({ block }) => {
  for (const key of Object.keys(block)) {
    if (key.startsWith(`attributes`)) {
      return block[key]
    }
  }

  return null
}

const createBlocksComponent = async ({ node, matchBlock, ...options }) => {
  const { store, getNodesByType } = options

  const asPreview = node.internal.type === `WpBlockEditorPreview`

  const componentByBlockName = new Map()

  const innerBlocksLevel = await visitBlocks({
    blocks: node.blocks,
    visitor: async ({ block }) => {
      componentByBlockName.set(block.name, await matchBlock({ ...options, block }))

      if (block.name === `core/block`) {
        const { ref } = getBlockAtrributes({ block })

        for (const reusableBlockNode of getNodesByType(`WpReusableBlock`)) {
          if (reusableBlockNode.databaseId === ref) {
            return {
              ...block,
              innerBlocks: reusableBlockNode.blocks,
            }
          }
        }
      }

      return block
    },
  })

  const fragmentName = `Blocks${node.databaseId}`
  const components = Array.from(componentByBlockName.values())
  const fieldName = typenameToFieldName({ typename: node.internal.type })

  const source = `/* eslint-disable */
/* Warning: this file is autogerated, any changes would be lost */
import React, { useMemo } from 'react'
import { graphql, useStaticQuery } from 'gatsby'

${components.map(({ componentPath, typename }) => `import ${typename} from '${componentPath}'`).join(`\n`)}

${
  asPreview
    ? `
const visitor = ({blocks, visit}) => {

  for (let block of blocks) {
    const result = visit({block})

    if (result || visitor({blocks: block.innerBlocks || [], visit})) {
      return true
    }
  }

  return false;
}
`
    : ``
}

const Blocks = ({ blocks = [], previewUUID }) => {
  return (
    <>
      {useMemo(() => {
        ${
          asPreview
            ? `
        if (!previewUUID) {
          return blocks
        }

        const result = []

        visitor({blocks, visit: ({block}) => {
          if (block.previewUUID === previewUUID) {
            result.push(block)
            return true
          }

          return false
        }})

        return result`
            : `
        return blocks`
        }
      }, [blocks, previewUUID]).map((block, i) => {
        const children = block.innerBlocks ? <Blocks blocks={block.innerBlocks} previewUUID={previewUUID} /> : null;

        ${components
          .map(
            ({ typename }) => `if (block.__typename === '${typename}') {
            return <${typename} {...block} children={children} key={i} />
          }`
          )
          .join(`\n        `)}

        return null;
      })}
    </>
  );
};

export default ({ previewUUID }) => {

  const { ${fieldName}: { blocks } } = useStaticQuery(graphql\`
    ${createFragment({
      name: fragmentName,
      blockFragmentNames: Array.from(
        new Set(components.map(({ fragment }) => fragment && fragment.name.value).filter(Boolean))
      ),
      innerBlocksLevel,
      asPreview,
    })}
    query {
      ${fieldName}(id: {eq: "${node.id}"}) {
        blocks {
          ...${fragmentName}
        }
      }
    }\`)

  return <Blocks blocks={blocks} previewUUID={previewUUID} />
}
`
  const outputFile = path.join(store.getState().program.directory, BLOCKS_PATH, `${node.id}.js`)
  await writeFile({ filePath: outputFile, data: source })
  return outputFile
}

const isNodeWithBlocks = ({ node }) => node.internal.owner.startsWith(`gatsby-source-wordpress`) && node.blocks

/**
 * MODULE VARIABLES
 */

// stores instance of chokidar watcher (for detecting changes through `develop` mode)
let watcher
//
let matchBlock = createBlockMatcher()

const previewPages = new Set()

exports.onCreateNode = async (options, pluginOptions) => {
  const {
    node,
    actions: { createNodeField },
  } = options

  if (node.internal.owner.startsWith(`gatsby-source-wordpress`)) {
    if (isNodeWithBlocks({ node })) {
      createNodeField({
        node,
        name: `blocksComponent`,
        value: await registerComponent({
          component: await createBlocksComponent({ ...options, matchBlock }, pluginOptions),
        }),
      })
    }
  }
}

exports.createResolvers = async ({ createResolvers, getNodes, store }) => {
  const typenames = new Set([`WpBlockEditorPreview`])
  const blockTypenames = new Set()

  for (const type of store.getState().schemaCustomization.types) {
    const config = type.typeOrTypeDef && type.typeOrTypeDef.config

    if (config) {
      const interfaces = config && config.interfaces

      if (interfaces) {
        if (interfaces.includes(`WpBlockEditorContentNode`)) {
          typenames.add(config.name)
        } else if (interfaces.includes(`WpBlock`)) {
          blockTypenames.add(config.name)
        }
      }
    }
  }

  const resolvers = {}

  blockTypenames.forEach(type => {
    resolvers[type] = {
      innerBlocks: {
        resolve: async (block, args, context, info) => {
          if (block.name === `core/block`) {
            const { ref } = getBlockAtrributes({ block })

            const reusableBlock = await context.nodeModel.runQuery({
              query: {
                filter: {
                  databaseId: {
                    eq: ref,
                  },
                },
              },
              type: `WpReusableBlock`,
              firstOnly: true,
            })

            if (!reusableBlock) {
              return null
            }

            context.nodeModel.trackPageDependencies(reusableBlock)
            return reusableBlock.blocks
          }

          return block.innerBlocks
        },
      },
    }
  })

  typenames.forEach(typename => {
    resolvers[typename] = {
      Blocks: createResolverField({
        resolve: async (node, args, context, info) => {
          if (node.fields) {
            context.nodeModel.trackPageDependencies(node.fields)
          }

          return node.fields && node.fields.blocksComponent
        },
      }),
    }
  })

  createResolvers(resolvers)
}

exports.createPages = async ({ getNodesByType, actions, store }, pluginOptions) => {
  const { createPage } = actions

  const nodes = getNodesByType(`WpBlockEditorPreview`)
  previewPages.clear()

  for (const node of nodes) {
    const component = path.join(store.getState().program.directory, PAGES_PATH, `${node.uri}.js`)

    await writeFile({
      filePath: component,
      data: `
import React from "react"
import { graphql, useStaticQuery } from "gatsby"
import BlockPreview from "gatsby-theme-wordpress-gutenberg/src/components/previews/block-preview"


export default props => {
  const data = useStaticQuery(graphql\`
    query GetThemeWordpressGutenbergBlockPreview${node.databaseId} {
      wpBlockEditorPreview(id: { eq: "${node.id}" }) {
        Blocks
      }
    }
  \`)

  const Blocks = data?.wpBlockEditorPreview?.Blocks
  return <BlockPreview Blocks={Blocks} />
}
`,
    })

    createPage({
      path: node.uri,
      component,
    })

    previewPages.add(node.uri)
  }

  if (nodes.length)
    setTimeout(() => {
      const time = new Date()
      fs.utimesSync(__filename, time, time)
    }, 0)
}

exports.createPagesStatefully = (options, pluginOptions) => {
  if (process.env.NODE_ENV === `development`) {
    if (watcher) {
      return
    }

    // to enhance developer experience we will track changes in all
    // child themes/root project's src/gatsby-theme-wordpress-gutenberg/{components/templates} and the theme itself
    // and regenerate source files upon change
    const {
      store,
      reporter,
      getNodes,
      actions: { createNodeField },
    } = options

    const program = store.getState().program
    const exts = program.extensions.map(e => `${e.slice(1)}`).join(`,`)

    const refresh = async () => {
      matchBlock = createBlockMatcher()

      for (const node of getNodes()) {
        if (isNodeWithBlocks({ node })) {
          createNodeField({
            node,
            name: `blocksComponent`,
            value: await registerComponent({
              component: await createBlocksComponent({ ...options, node, matchBlock }, pluginOptions),
            }),
          })
        }
      }
    }

    const cb = () => {
      // if we are already running return
      if (cb.current) {
        return
      }

      reporter.info(`Refreshing Blocks components`)
      cb.current = refresh()
        .catch(err => {
          reporter.error(err)
        })
        .finally(() => {
          cb.current = null
        })
    }

    watcher = chokidar
      .watch(
        store.getState().flattenedPlugins.map(flattenedPlugin => {
          const directoryPath = flattenedPlugin.pluginFilepath
          return `${directoryPath}/${
            flattenedPlugin.name === PLUGIN_NAME ? `src/` : `src/gatsby-theme-wordpress-gutenberg/`
          }components/**/*.{${exts}}`
        }),
        { ignoreInitial: true }
      )
      .on(`all`, cb)
  }
}

exports.onCreateDevServer = ({ app }) => {
  app.get("*", function (req, res, next) {
    if (previewPages.has(req.path)) {
      res.set("Access-Control-Expose-Headers", "X-Theme-Wordpress-Gutenberg-Preview-Page")
      res.set("X-Theme-Wordpress-Gutenberg-Preview-Page", "true")
    }

    next()
  })
}
